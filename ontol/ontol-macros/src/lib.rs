use proc_macro::TokenStream;
use quote::{format_ident, quote};
use syn::parse_macro_input;

mod ontol_debug;
mod rustdoc;

#[proc_macro_derive(OntolDebug)]
pub fn derive_ontol_debug(input: TokenStream) -> TokenStream {
    let output = ontol_debug::derive(parse_macro_input!(input as syn::DeriveInput));
    TokenStream::from(output)
}

#[proc_macro_derive(RustDoc)]
pub fn derive_rustdoc(input: TokenStream) -> TokenStream {
    let output = rustdoc::derive(parse_macro_input!(input as syn::DeriveInput));
    TokenStream::from(output)
}

/// Init tracing before a test is run.
///
/// This init code is shorter than the one generated by https://docs.rs/test-log/.
#[proc_macro_attribute]
pub fn test(attr: TokenStream, item: TokenStream) -> TokenStream {
    let syn::ItemFn {
        attrs,
        vis,
        sig,
        mut block,
    } = parse_macro_input!(item as syn::ItemFn);

    let test_attr = if attr.is_empty() {
        quote! { ::core::prelude::v1::test }
    } else {
        attr.into()
    };

    let tracing_init = quote! {
        let _ = ::tracing_subscriber::FmtSubscriber::builder()
            .with_env_filter(::tracing_subscriber::EnvFilter::from_default_env())
            .with_test_writer()
            .try_init();
    };

    block.stmts.insert(0, syn::parse_quote!(#tracing_init));

    let out = quote! {
        #[#test_attr]
        #(#attrs)*
        #vis #sig #block
    };

    TokenStream::from(out)
}

#[proc_macro_attribute]
pub fn datastore_test(attr: TokenStream, item: TokenStream) -> TokenStream {
    let syn::ItemFn {
        attrs,
        vis,
        sig,
        block,
    } = parse_macro_input!(item as syn::ItemFn);

    struct DataStore {
        identifier: &'static str,
        skip_env_var: &'static str,
    }

    let data_stores = &[
        DataStore {
            identifier: "inmemory",
            skip_env_var: "DOMAIN_ENGINE_SKIP_INMEMORY_TESTS",
        },
        DataStore {
            identifier: "arango",
            skip_env_var: "DOMAIN_ENGINE_SKIP_ARANGO_TESTS",
        },
    ];

    let test_attr = if attr.is_empty() {
        quote! { ::core::prelude::v1::test }
    } else {
        attr.into()
    };

    let super_ident = &sig.ident;
    let asyncness = &sig.asyncness;
    let dot_await = match asyncness {
        Some(_) => quote! { .await },
        None => quote! {},
    };

    let test_items = data_stores.iter().map(|data_store| {
        let ds_identifier = data_store.identifier;
        let skip_env_var = data_store.skip_env_var;
        let test_ident = format_ident!("ds_{}", ds_identifier);

        quote! {
            #[ontol_macros::test(#test_attr)]
            #asyncness fn #test_ident() {
                if ::std::env::var(#skip_env_var).is_ok() {
                    return;
                }

                super::#super_ident(#ds_identifier) #dot_await
            }
        }
    });

    let tokens = quote! {
        #(#attrs)*
        #vis #sig #block

        mod #super_ident {
            #(#test_items)*
        }
    };

    tokens.into()
}
