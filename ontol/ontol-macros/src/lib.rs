#![forbid(unsafe_code)]

use std::collections::HashSet;

use proc_macro::TokenStream;
use quote::{format_ident, quote, ToTokens, TokenStreamExt};
use syn::{parenthesized, parse_macro_input, Token};

mod ontol_debug;
mod rustdoc;

#[proc_macro_derive(OntolDebug)]
pub fn derive_ontol_debug(input: TokenStream) -> TokenStream {
    let output = ontol_debug::derive(parse_macro_input!(input as syn::DeriveInput));
    TokenStream::from(output)
}

#[proc_macro_derive(RustDoc)]
pub fn derive_rustdoc(input: TokenStream) -> TokenStream {
    let output = rustdoc::derive(parse_macro_input!(input as syn::DeriveInput));
    TokenStream::from(output)
}

/// Init tracing before a test is run.
///
/// This init code is shorter than the one generated by https://docs.rs/test-log/.
#[proc_macro_attribute]
pub fn test(attr: TokenStream, item: TokenStream) -> TokenStream {
    let syn::ItemFn {
        attrs,
        vis,
        sig,
        mut block,
    } = parse_macro_input!(item as syn::ItemFn);

    let test_attr = if attr.is_empty() {
        quote! { ::core::prelude::v1::test }
    } else {
        attr.into()
    };

    let tracing_init = quote! {
        let _ = ::tracing_subscriber::FmtSubscriber::builder()
            .with_env_filter(::tracing_subscriber::EnvFilter::from_default_env())
            .with_test_writer()
            .try_init();
    };

    block.stmts.insert(0, syn::parse_quote!(#tracing_init));

    let out = quote! {
        #[#test_attr]
        #(#attrs)*
        #vis #sig #block
    };

    TokenStream::from(out)
}

#[proc_macro_attribute]
pub fn datastore_test(attr: TokenStream, item: TokenStream) -> TokenStream {
    let syn::ItemFn {
        attrs,
        vis,
        sig,
        block,
    } = parse_macro_input!(item as syn::ItemFn);

    struct DataStore {
        identifier: &'static str,
        skip_env_var: &'static str,
    }

    let data_stores = &[
        DataStore {
            identifier: "inmemory",
            skip_env_var: "DOMAIN_ENGINE_SKIP_INMEMORY_TESTS",
        },
        DataStore {
            identifier: "arango",
            skip_env_var: "DOMAIN_ENGINE_SKIP_ARANGO_TESTS",
        },
        DataStore {
            identifier: "pg",
            skip_env_var: "DOMAIN_ENGINE_SKIP_PG_TESTS",
        },
    ];

    let data_store_attrs = parse_macro_input!(attr as DatastoreAttrs);

    let mut test_attr = quote! { ::core::prelude::v1::test };
    let mut ignore: HashSet<String> = Default::default();

    for element in data_store_attrs.elements {
        match element {
            DatastoreAttr::Path(path) => {
                test_attr = quote! { #path };
            }
            DatastoreAttr::Ignore(data_stores) => {
                ignore.extend(data_stores);
            }
        }
    }

    let super_ident = &sig.ident;
    let asyncness = &sig.asyncness;
    let dot_await = match asyncness {
        Some(_) => quote! { .await },
        None => quote! {},
    };

    let test_items = data_stores.iter().map(|data_store| {
        let ds_identifier = data_store.identifier;
        let skip_env_var = data_store.skip_env_var;
        let test_ident = format_ident!("ds_{}", ds_identifier);

        let ignore_attr = if ignore.contains(ds_identifier) {
            quote! { #[ignore] }
        } else {
            quote! {}
        };

        quote! {
            #[ontol_macros::test(#test_attr)]
            #ignore_attr
            #asyncness fn #test_ident() {
                if ::std::env::var(#skip_env_var).is_ok() {
                    return;
                }

                super::#super_ident(#ds_identifier) #dot_await
            }
        }
    });

    let tokens = quote! {
        #(#attrs)*
        #vis #sig #block

        mod #super_ident {
            #(#test_items)*
        }
    };

    tokens.into()
}

struct DatastoreAttrs {
    elements: Vec<DatastoreAttr>,
}

enum DatastoreAttr {
    Path(proc_macro2::TokenStream),
    Ignore(Vec<String>),
}

impl syn::parse::Parse for DatastoreAttrs {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut elements = vec![];
        loop {
            let ident: syn::Ident = input.parse::<syn::Ident>()?;

            match ident.to_string().as_str() {
                "ignore" => {
                    let content;
                    parenthesized!(content in input);

                    let mut ignore_vec = vec![];

                    loop {
                        let ignored = content.parse::<syn::LitStr>()?;
                        ignore_vec.push(ignored.value());

                        if content.peek(Token![,]) {
                            content.parse::<Token![,]>()?;
                        } else {
                            break;
                        }
                    }

                    elements.push(DatastoreAttr::Ignore(ignore_vec));
                }
                _ => {
                    let mut path = proc_macro2::TokenStream::new();
                    path.append(ident);

                    while input.peek(Token![::]) {
                        path.append_all(input.parse::<Token![::]>()?.into_token_stream());
                        path.append(input.parse::<syn::Ident>()?);
                    }

                    elements.push(DatastoreAttr::Path(path));
                }
            }

            if input.peek(Token![,]) {
                input.parse::<Token![,]>()?;
            } else {
                break;
            }
        }

        Ok(Self { elements })
    }
}
