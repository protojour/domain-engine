/// The conduit persistence layer
domain conduit_db ()

def user_id (rel .is: uuid)
def slug (rel.is: text)
def tag (rel.is: text)

def User (
    // TODO: This must be an Authly user id
    rel .'user_id'[rel .gen: auto]|id: user_id
    // TODO: This is.. an authly user name? Maybe?
    rel .'username': text

    // TODO: Should not store auth-related fields in memoriam,
    // this is the responsibility of Authly.
    rel .'email': text
    rel .'password_hash': text

    rel .'bio'[rel .default := '']: text
    rel .'image'?: text

    // TODO(constraint): User cannot follow itself
    rel .'following'::'followed_by'? {User}
)

def Article (
    rel .'article_id'[rel .gen: auto]|id: (rel .is: uuid)
    // TODO(constraint): slug is unique
    rel .'slug': slug
    rel .'title': text
    rel .'description': text
    rel .'body': text
    rel .'created_at'[rel .gen: create_time]: datetime
    rel .'updated_at'[rel .gen: update_time]: datetime

    rel .order[rel .0: 'title']: alphabetical
    rel .order[
        rel .0: 'created_at'
        rel .direction: descending
    ]: by_date
)

def Comment (
    rel .'id'[rel .gen: auto]|id: (rel .is: serial)
    rel .'body': text
    rel .'created_at'[rel .gen: create_time]: datetime
    rel .'updated_at'[rel .gen: update_time]: datetime
)

def TagEntity (
    rel .'tag'|id: tag
)

rel {Article} 'author'::'authored_articles'? User
rel Article 'favorited_by'::'favorited'? {User}
rel {TagEntity} 'tagged'::'tags'? {Article}
rel {Comment} 'comment_on'?::'comments'? Article
rel {Comment} 'author'::'authored_comments'? User

sym {
    /// An ordering by date
    by_date,

    /// An alphabetical ordering
    alphabetical,
}

map users(
    (),
    User { ..@match User() }
)

map articles(
    (),
    Article { ..@match Article() }
)
