# The keyword `rel` has three arguments: subject, relation and object:
# The relation is always syntactically marked:
rel subject { relation } object

# subject and object may be omitted, if encolsed in contextual syntax.
# The following simply _desugars_ into the full relation syntax.
type T {
    rel [relation] some_object   # T acts as the subject
    rel some_subject [relation]  # T acts as the object, i.e. declare a new "incoming" relation!
}

type artist {
    rel ['plays' | 'played-by'] instrument
    rel listener ['listens-to' | 'listened-to-by']
}

type meters {
    rel . [int]
}

type my-id {
    rel '' ['my_id/'] [uuid]
    rel '' ['my_id2/'] [uuid]
}

type Geomtry {
    rel . [Point]
    rel . [MultiPoint]
}

# in eq expressions:
# (just for fun, this example tries to "invert" a tree while translating..
#   if that's even possible. At some point there is no parent, which would mean that the :siblings is totally undefined)
# anyway it has to be two different types of trees.

eq(:children* :siblings*) {
    tree_a {
        rel ['children'] :children
        rel :siblings ['children']
    }
    tree_b {
        rel ['children'] :siblings
        rel :children ['children']
    }
}

eq(:x) {
    meters { :x }
    millimeters { :x * 1000 }
}

# variable syntax
# a :colon syntax has been used. But that would conflict with how relation parameters are defined in new_syntax2.ont.
