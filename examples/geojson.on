/// A position is the fundamental geometry construct.
type position {
    rel .0..2: f64
}

/// A list of two positions or more.
type position-list {
    rel . ..2: position
    rel . 2..: position
}

/// To specify a constraint specific to Polygons, it is useful to
/// introduce the concept of a linear ring:
///
/// A linear ring is a closed LineString with four or more positions.
///
/// * The first and last positions are equivalent, and they MUST contain
///   identical values; their representation SHOULD also be identical.
/// * A linear ring is the boundary of a surface or the boundary of a
///   hole in a surface.
/// * A linear ring MUST follow the right-hand rule with respect to the
///   area it bounds, i.e., exterior rings are counterclockwise, and
///   holes are clockwise.
///
type position-ring {
    rel . ..4: position
    rel . 4..: position
}

/// For type "Point", the "coordinates" member is a single position.
pub type Point {
    rel .'type': 'Point'
    rel .'coordinates': position
}

/// For type "MultiPoint", the "coordinates" member is an array of
/// positions.
pub type MultiPoint {
    rel .'type': 'MultiPoint'
    rel .'coordinates': [position]
}

/// For type "LineString", the "coordinates" member is an array of two or
/// more positions.
pub type LineString {
    rel .'type': 'LineString'
    rel .'coordinates': position-list
}

/// For type "MultiLineString", the "coordinates" member is an array of
/// LineString coordinate arrays.
pub type MultiLineString {
    rel . 'type': 'MultiLineString'
    rel . 'coordinates': [position-list]
}

/// For type "Polygon", the "coordinates" member MUST be an array of
/// linear ring coordinate arrays.
pub type Polygon {
    rel .'type': 'Polygon'
    rel .'coordinates': position-ring
}

/// For type "MultiPolygon", the "coordinates" member is an array of
/// Polygon coordinate arrays.
pub type MultiPolygon {
    rel .'type': 'MultiPolygon'
    rel .'coordinates': [position-ring]
}

/// LeafGeometry is a union of geometries that does not include `GeometryCollection`.
pub type LeafGeometry {
    rel .is?: Point
    rel .is?: MultiPoint
    rel .is?: LineString
    rel .is?: MultiLineString
    rel .is?: Polygon
    rel .is?: MultiPolygon
}


/// A GeoJSON object with type "GeometryCollection" is a Geometry object.
/// A GeometryCollection has a member with the name "geometries".  The
/// value of "geometries" is an array.  Each element of this array is a
/// GeoJSON Geometry object.  It is possible for this array to be empty.
pub type GeometryCollection {
    rel .'type': 'GeometryCollection'
    rel .'geometries': [LeafGeometry]
}

/// A Geometry object represents points, curves, and surfaces in
/// coordinate space.  Every Geometry object is a GeoJSON object no
/// matter where it occurs in a GeoJSON text.
///
/// Note: Geometry is an extension of LeafGeometry + GeometryCollection.
pub type Geometry {
    rel .is?: Point
    rel .is?: MultiPoint
    rel .is?: LineString
    rel .is?: MultiLineString
    rel .is?: Polygon
    rel .is?: MultiPolygon
    rel .is?: GeometryCollection
}

type GeometryOrNull {
    // TODO: Not supported yet (union tree):
    rel .is: Geometry
    // rel _ is?: ()
}

/// A Feature object represents a spatially bounded thing.  Every Feature
/// object is a GeoJSON object no matter where it occurs in a GeoJSON
/// text.
type Feature<properties = ()>
rel Feature<> 'type': 'Feature'
rel Feature<> 'geometry': GeometryOrNull

// FIXME: Features is a map of 'anything'.
// This could be a good use case for generics in ONTOL.
rel Feature<properties> 'properties': ()

/// A GeoJSON object with the type "FeatureCollection" is a
/// FeatureCollection object.  A FeatureCollection object has a member
/// with the name "features".  The value of "features" is a JSON array.
/// Each element of the array is a Feature object as defined above.  It
/// is possible for this array to be empty.
type FeatureCollection<properties = ()>
rel FeatureCollection<> 'type': 'FeatureCollection'
rel FeatureCollection<properties> 'features': [Feature<properties>]
